// Code generated by go-swagger; DO NOT EDIT.

package assisted_service_iso

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"io"
	"net/http"

	"github.com/go-openapi/runtime"
	v1 "github.com/openshift/assisted-service/models/v1"
)

// DownloadISOOKCode is the HTTP code returned for type DownloadISOOK
const DownloadISOOKCode int = 200

/*DownloadISOOK Success.

swagger:response downloadISOOK
*/
type DownloadISOOK struct {

	/*
	  In: Body
	*/
	Payload io.ReadCloser `json:"body,omitempty"`
}

// NewDownloadISOOK creates DownloadISOOK with default headers values
func NewDownloadISOOK() *DownloadISOOK {

	return &DownloadISOOK{}
}

// WithPayload adds the payload to the download i s o o k response
func (o *DownloadISOOK) WithPayload(payload io.ReadCloser) *DownloadISOOK {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download i s o o k response
func (o *DownloadISOOK) SetPayload(payload io.ReadCloser) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadISOOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(200)
	payload := o.Payload
	if err := producer.Produce(rw, payload); err != nil {
		panic(err) // let the recovery middleware deal with this
	}
}

// DownloadISOUnauthorizedCode is the HTTP code returned for type DownloadISOUnauthorized
const DownloadISOUnauthorizedCode int = 401

/*DownloadISOUnauthorized Unauthorized.

swagger:response downloadISOUnauthorized
*/
type DownloadISOUnauthorized struct {

	/*
	  In: Body
	*/
	Payload *v1.InfraError `json:"body,omitempty"`
}

// NewDownloadISOUnauthorized creates DownloadISOUnauthorized with default headers values
func NewDownloadISOUnauthorized() *DownloadISOUnauthorized {

	return &DownloadISOUnauthorized{}
}

// WithPayload adds the payload to the download i s o unauthorized response
func (o *DownloadISOUnauthorized) WithPayload(payload *v1.InfraError) *DownloadISOUnauthorized {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download i s o unauthorized response
func (o *DownloadISOUnauthorized) SetPayload(payload *v1.InfraError) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadISOUnauthorized) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(401)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// DownloadISOForbiddenCode is the HTTP code returned for type DownloadISOForbidden
const DownloadISOForbiddenCode int = 403

/*DownloadISOForbidden Forbidden.

swagger:response downloadISOForbidden
*/
type DownloadISOForbidden struct {

	/*
	  In: Body
	*/
	Payload *v1.InfraError `json:"body,omitempty"`
}

// NewDownloadISOForbidden creates DownloadISOForbidden with default headers values
func NewDownloadISOForbidden() *DownloadISOForbidden {

	return &DownloadISOForbidden{}
}

// WithPayload adds the payload to the download i s o forbidden response
func (o *DownloadISOForbidden) WithPayload(payload *v1.InfraError) *DownloadISOForbidden {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download i s o forbidden response
func (o *DownloadISOForbidden) SetPayload(payload *v1.InfraError) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadISOForbidden) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(403)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// DownloadISONotFoundCode is the HTTP code returned for type DownloadISONotFound
const DownloadISONotFoundCode int = 404

/*DownloadISONotFound Error.

swagger:response downloadISONotFound
*/
type DownloadISONotFound struct {

	/*
	  In: Body
	*/
	Payload *v1.Error `json:"body,omitempty"`
}

// NewDownloadISONotFound creates DownloadISONotFound with default headers values
func NewDownloadISONotFound() *DownloadISONotFound {

	return &DownloadISONotFound{}
}

// WithPayload adds the payload to the download i s o not found response
func (o *DownloadISONotFound) WithPayload(payload *v1.Error) *DownloadISONotFound {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download i s o not found response
func (o *DownloadISONotFound) SetPayload(payload *v1.Error) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadISONotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(404)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// DownloadISOInternalServerErrorCode is the HTTP code returned for type DownloadISOInternalServerError
const DownloadISOInternalServerErrorCode int = 500

/*DownloadISOInternalServerError Error.

swagger:response downloadISOInternalServerError
*/
type DownloadISOInternalServerError struct {

	/*
	  In: Body
	*/
	Payload *v1.Error `json:"body,omitempty"`
}

// NewDownloadISOInternalServerError creates DownloadISOInternalServerError with default headers values
func NewDownloadISOInternalServerError() *DownloadISOInternalServerError {

	return &DownloadISOInternalServerError{}
}

// WithPayload adds the payload to the download i s o internal server error response
func (o *DownloadISOInternalServerError) WithPayload(payload *v1.Error) *DownloadISOInternalServerError {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download i s o internal server error response
func (o *DownloadISOInternalServerError) SetPayload(payload *v1.Error) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadISOInternalServerError) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(500)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}
