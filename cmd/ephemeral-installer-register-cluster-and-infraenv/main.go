/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
The ephemeral-installer-register-cluster-and-infraenv is a client that runs
in a bootable image containing all components needed to run assisted-service
and the agent. The image is intend to be used by users to who are not currently
supported by the IPI installer. It is also targeted for disconnected
on-premises use.

The client performs three main tasks:
1. Reads in ZTP manifests containing information about cluster 0. The manifests
   are either provided by users or generated by the ISO generation tool using
   source files like install-config.yaml. The manifests are bind mounted
   to the container running the client.
2. Registers a cluster in assisted service using the REST-API.
3. Registers a infraenv using the REST-API. The infraenv contains a
   reference to the created cluster and contains any nmstate configs.

A kube-api is not available in the ephemeral-installer environment. This
is why the ZTP manifests are not applied directly to kubernetes. Instead,
the manifests are translated into create cluster and infraenv params, and
then posted to the REST-API to create those resources.

This client is needed to register the cluster and infraenv to minimize
user interaction and to enable automation use cases.

A service running on the image, waits for the infraenv to be registered
to assisted-service. Once registered, an infraenv id is available and
the agent is started. The agent registers the host to assisted service
allowing the installation to continue.

A separate service waits for host validation to complete and initiates
the cluster installation when the cluster status becomes ready.

These two services are embedded in the image generated by the ephemeral
installer tooling and are not part of this client.
*/

package main

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"path"
	"reflect"
	"strings"

	"github.com/kelseyhightower/envconfig"
	hiveext "github.com/openshift/assisted-service/api/hiveextension/v1beta1"
	aiv1beta1 "github.com/openshift/assisted-service/api/v1beta1"
	"github.com/openshift/assisted-service/client"
	"github.com/openshift/assisted-service/client/installer"
	"github.com/openshift/assisted-service/internal/controller/controllers"
	"github.com/openshift/assisted-service/models"
	hivev1 "github.com/openshift/hive/apis/hive/v1"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	"sigs.k8s.io/yaml"
)

var Options struct {
	ClusterDeploymentFile   string `envconfig:"CLUSTER_DEPLOYMENT_FILE" default:"/manifests/cluster-deployment.yaml"`
	AgentClusterInstallFile string `envconfig:"AGENT_CLUSTER_INSTALL_FILE" default:"/manifests/agent-cluster-install.yaml"`
	InfraEnvFile            string `envconfig:"INFRA_ENV_FILE" default:"/manifests/infraenv.yaml"`
	PullSecretFile          string `envconfig:"PULL_SECRET_FILE" default:"/manifests/pull-secret.yaml"`
	ClusterImageSetFile     string `envconfig:"CLUSTER_IMAGE_SET_FILE" default:"/manifests/cluster-image-set.yaml"`
	NMStateConfigFile       string `envconfig:"NMSTATE_CONFIG_FILE" default:"/manifests/nmstateconfig.yaml"`
	ServiceBaseUrl          string `envconfig:"SERVICE_BASE_URL" default:""`
	ImageTypeISO            string `envconfig:"IMAGE_TYPE_ISO" default:"full-iso"`
}

func main() {
	err := envconfig.Process("", &Options)
	log := log.New()
	if err != nil {
		log.Fatal(err.Error())
	}

	log.Info("Reading ZTP manifests")

	var cd hivev1.ClusterDeployment
	if cdErr := getFileData(Options.ClusterDeploymentFile, &cd); cdErr != nil {
		log.Fatal(cdErr.Error())
	}

	var aci hiveext.AgentClusterInstall
	if aciErr := getFileData(Options.AgentClusterInstallFile, &aci); aciErr != nil {
		log.Fatal(aciErr.Error())
	}

	var secret corev1.Secret
	if secretErr := getFileData(Options.PullSecretFile, &secret); secretErr != nil {
		log.Fatal(secretErr.Error())
	}
	pullSecret := secret.StringData[".dockerconfigjson"]

	releaseImageVersion, releaseImageCPUArch := getReleaseVersionAndCpuArch(getReleaseVersion())
	log.Info("releaseImage: " + getReleaseVersion())
	log.Infof("releaseImage version %s cpuarch %s", releaseImageVersion, releaseImageCPUArch)

	var infraEnv aiv1beta1.InfraEnv
	if infraenvErr := getFileData(Options.InfraEnvFile, &infraEnv); infraenvErr != nil {
		log.Fatal(infraenvErr.Error())
	}

	var nmStateConfig aiv1beta1.NMStateConfig
	if nmStateErr := getFileData(Options.NMStateConfigFile, &nmStateConfig); nmStateErr != nil {
		log.Fatal(nmStateErr.Error())
	}

	staticNetworkConfig, processErr := processNMStateConfig(log, infraEnv, nmStateConfig)
	if processErr != nil {
		log.Fatal(processErr.Error())
	}

	clientConfig := client.Config{}
	u, parseErr := url.Parse(Options.ServiceBaseUrl)
	if parseErr != nil {
		log.Fatal(parseErr, "Failed parsing inventory URL")
	}
	u.Path = path.Join(u.Path, client.DefaultBasePath)
	clientConfig.URL = u
	bmInventory := client.New(clientConfig)
	ctx := context.Background()

	log.Info("SERVICE_BASE_URL: " + Options.ServiceBaseUrl)
	log.Info("Registering cluster")

	clusterParams := controllers.CreateClusterParams(&cd, &aci, pullSecret, releaseImageVersion, releaseImageCPUArch)
	clientClusterParams := &installer.V2RegisterClusterParams{
		NewClusterParams: clusterParams,
	}
	clusterResult, registerClusterErr := bmInventory.Installer.V2RegisterCluster(ctx, clientClusterParams)
	if registerClusterErr != nil {
		log.Fatal(registerClusterErr, "Failed to register cluster with assisted-service")
	}

	modelsCluster := clusterResult.Payload

	log.Info("Registered cluster with id: " + modelsCluster.ID.String())

	log.Info("Registering infraenv")

	infraEnvParams := controllers.CreateInfraEnvParams(&infraEnv, modelsCluster, models.ImageType(Options.ImageTypeISO), pullSecret)

	if len(staticNetworkConfig) > 0 {
		log.Infof("Added %d nmstateconfigs", len(staticNetworkConfig))
		infraEnvParams.InfraenvCreateParams.StaticNetworkConfig = staticNetworkConfig
	}

	clientInfraEnvParams := &installer.RegisterInfraEnvParams{
		InfraenvCreateParams: infraEnvParams.InfraenvCreateParams,
	}
	infraEnvResult, registerInfraEnvErr := bmInventory.Installer.RegisterInfraEnv(ctx, clientInfraEnvParams)
	if registerInfraEnvErr != nil {
		log.Fatal(registerInfraEnvErr, "Failed to register infraenv with assisted-service")
	}

	modelsInfraEnv := infraEnvResult.Payload

	log.Info("Registered infraenv with id: " + modelsInfraEnv.ID.String())
}

func getReleaseVersion() string {
	var clusterImageSet hivev1.ClusterImageSet
	if err := getFileData(Options.ClusterImageSetFile, &clusterImageSet); err != nil {
		log.Fatal(err.Error())
	}
	return clusterImageSet.Spec.ReleaseImage
}

func getReleaseVersionAndCpuArch(releaseImage string) (version string, cpuArch string) {
	// releaseImage is in the form: quay.io/openshift-release-dev/ocp-release:4.9.17-x86_64
	versionCpuArch := strings.Split(releaseImage, ":")[1]
	// versionCpuArch is 4.9.17-x86_64
	versionCpuArchSplit := strings.Split(versionCpuArch, "-")
	if len(versionCpuArchSplit) > 2 {
		// case: 4.10.0-rc1-x86_64
		version = strings.Join(versionCpuArchSplit[:2], "-")
		cpuArch = versionCpuArchSplit[2]
	} else {
		// case: 4.10.1-x86_64
		version = versionCpuArchSplit[0]
		cpuArch = versionCpuArchSplit[1]
	}
	return version, cpuArch
}

// Read a Yaml file and unmarshal the contents
func getFileData(filePath string, output interface{}) error {

	contents, err := os.ReadFile(filePath)
	if err != nil {
		err = fmt.Errorf("error reading file %s: %w", filePath, err)
	} else if err = yaml.Unmarshal(contents, output); err != nil {
		err = fmt.Errorf("error unmarshalling contents of %s: %w", filePath, err)
	}

	return err
}

func validateNMStateConfigAndInfraEnv(nmStateConfig aiv1beta1.NMStateConfig, infraEnv aiv1beta1.InfraEnv) error {
	if len(nmStateConfig.ObjectMeta.Labels) == 0 {
		return errors.Errorf("nmstateconfig does not have any labels set")
	}

	if len(infraEnv.Spec.NMStateConfigLabelSelector.MatchLabels) == 0 {
		return errors.Errorf("infraenv does not have any labels set with NMStateConfigLabelSelector.MatchLabels")
	}

	if !reflect.DeepEqual(infraEnv.Spec.NMStateConfigLabelSelector.MatchLabels, nmStateConfig.ObjectMeta.Labels) {
		return errors.Errorf("infraenv and nmstateconfig labels do not match")
	}

	return nil
}

func processNMStateConfig(log log.FieldLogger, infraEnv aiv1beta1.InfraEnv, nmStateConfig aiv1beta1.NMStateConfig) ([]*models.HostStaticNetworkConfig, error) {

	err := validateNMStateConfigAndInfraEnv(nmStateConfig, infraEnv)
	if err != nil {
		return nil, err
	}

	var staticNetworkConfig []*models.HostStaticNetworkConfig
	staticNetworkConfig = append(staticNetworkConfig, &models.HostStaticNetworkConfig{
		MacInterfaceMap: controllers.BuildMacInterfaceMap(log, nmStateConfig),
		NetworkYaml:     string(nmStateConfig.Spec.NetConfig.Raw),
	})
	return staticNetworkConfig, nil
}
